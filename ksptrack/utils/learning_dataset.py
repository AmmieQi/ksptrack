import glob
import warnings, itertools, _pickle, progressbar, sys, os, datetime, yaml, hashlib, json
from ksptrack.cfgs import cfg
from ksptrack.utils import my_utils as utls
from ksptrack.utils import superpixel_utils as spix
from ksptrack.utils.data_manager import DataManager
import pandas as pd
import pickle as pk
import numpy as np
import matplotlib.pyplot as plt
from scipy import io
from scipy import ndimage
import skimage.segmentation
import networkx as nx
import logging

class LearningDataset(DataManager):
    """

    """

    def __init__(self,conf,pos_thr=0.1):

        DataManager.__init__(self,conf)
        self.conf = conf
        self.labels = None
        self.scores = None
        self.fnames = conf.frameFileNames
        self.y_true = None #This is generated by mouse-labeled ground-truths
        self.y = None
        self.y_images = None
        self.pos_thr = pos_thr #ratio above which sp is positive
        self.seeds = None
        #self.logger = logging.getLogger('LearningDataset')

    @property
    def X(self):
        sp_desc = self.get_sp_desc_from_file()
        return sp_desc['desc']

    @property
    def X_all_images(self):
        out = [utls.imread(self.conf.frameFileNames[i])[...,np.newaxis] for i in range(len(self.conf.frameFileNames))]
        return np.concatenate(out,axis=3)

    def set_seeds(self,seeds):

        self.seeds = seeds
        self.scores = utls.seeds_to_scores(self.get_labels(),seeds)

    @property
    def gt(self):
        gt_dir = os.path.join(self.conf.dataInRoot, self.conf.dataSetDir, self.conf.gtFrameDir)
        gtFileNames = utls.makeFrameFileNames(
            self.conf.framePrefix, self.conf.frameDigits, self.conf.gtFrameDir,
            self.conf.dataInRoot, self.conf.dataSetDir, self.conf.frameExtension)

        return utls.getPositives(gtFileNames)

    def make_y_map_true(self,map_):

        #self.logger.info('Making Y vector (true groundtruths)')
        overlap_maps = []
        labels = self.get_labels()
        with progressbar.ProgressBar(maxval=labels.shape[-1]) as bar:
            for i in range(labels.shape[-1]):
                overlap = np.zeros(labels[..., i].shape)
                bar.update(i)
                for j in np.unique(labels[...,i]):
                    mask = labels[...,i] == j
                    overlap_ = np.sum(map_[..., i] & mask)/np.sum(mask)
                    overlap += mask*overlap_

                overlap_maps.append(overlap)

        return np.asarray(overlap_maps).transpose((1,2,0))

    def make_y_array_true(self,map_):

        #self.logger.info('Making Y vector (true groundtruths)')
        y = []
        labels = self.get_labels()
        with progressbar.ProgressBar(maxval=labels.shape[-1]) as bar:
            for i in range(labels.shape[-1]):
                bar.update(i)
                for j in np.unique(labels[...,i]):
                    this_mask = labels[...,i] == j
                    this_overlap = np.logical_and(map_[...,i], this_mask)
                    y.append((i,j,np.sum(this_overlap)/np.sum(this_mask) > self.pos_thr))

        self.y_true = np.asarray(y)

    def make_y_array(self,seeds):

        #self.logger.info('Making Y vector')
        labels = self.get_labels()
        y = np.asarray([(i,j,0) for i in range(labels.shape[-1]) for j in np.unique(labels[...,i])])

        with progressbar.ProgressBar(maxval=seeds.shape[0]) as bar:
            for i in range(seeds.shape[0]):
                bar.update(i)
                idx = np.where(np.sum(y[:,:2] == seeds[i,:],axis=1) == 2)[0]
                y[idx,-1] = 1

        self.y = np.asarray(y)

    def __getstate__(self):
        out = dict()
        out['conf'] = self.conf
        out['scores'] = self.scores
        out['fnames'] = self.fnames
        #out['y_true'] = self.y_true
        #out['y'] = self.y
        out['pos_thr'] = self.pos_thr
        #out['seeds'] = self.seeds
        #out['X'] = self.X
        out['gt'] = self.gt


        return out
